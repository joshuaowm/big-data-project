<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FRACTAL PySpark Scaling Analysis</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
    <style>
        /* Define custom font and default layout styles */
        body { font-family: 'Inter', sans-serif; background-color: #f7f9fc; }
        .chart-container { 
            position: relative; 
            margin: 1rem 0; 
            padding: 1rem;
            background: white;
            border-radius: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            max-width: 100%;
        }
        .loading-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            border-radius: 1rem;
            text-align: center;
        }
    </style>
</head>
<body>

    <div class="p-4 sm:p-8">
        <header class="text-center mb-10">
            <h1 class="text-3xl sm:text-4xl font-extrabold text-gray-800 tracking-tight">
                Spark Scaling Experiment Results
            </h1>
            <p class="text-lg text-gray-500 mt-2">
                Upload your JSON metrics files below to view the performance curves.
            </p>
        </header>
        
        <!-- File Input Area -->
        <div class="flex flex-col items-center justify-center mb-8 p-4 bg-white rounded-xl shadow-lg border border-gray-100">
            <input 
                type="file" 
                id="jsonFileInput" 
                accept=".json" 
                multiple 
                class="hidden"
                onchange="handleFileSelect(event.target.files)"
            />
            <button 
                onclick="document.getElementById('jsonFileInput').click()" 
                id="loadButton"
                class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 px-6 rounded-xl transition duration-200 shadow-md transform hover:scale-[1.02]"
            >
                Load JSON Result Files (Select All)
            </button>
            <p id="fileStatus" class="mt-3 text-sm text-gray-500">
                Please select all metrics files from your experiment.
            </p>
        </div>

        <!-- Chart Containers -->
        <div id="chart-area" class="grid grid-cols-1 lg:grid-cols-2 xl:grid-cols-3 gap-6 relative">
            
            <div id="initial-overlay" class="loading-overlay">
                <p class="text-2xl font-medium text-gray-500">
                    <svg class="inline w-6 h-6 mr-2 text-indigo-600 animate-pulse" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>
                    Awaiting file selection...
                </p>
            </div>
            
            <!-- Canvases for Charts -->
            <div class="chart-container"><canvas id="t_overall_chart"></canvas></div>
            <div class="chart-container"><canvas id="t_total_pipeline_chart"></canvas></div>
            <div class="chart-container"><canvas id="t_load_chart"></canvas></div>
            <div class="chart-container"><canvas id="t_features_chart"></canvas></div>
            <div class="chart-container lg:col-span-2 xl:col-span-1"><canvas id="f1_score_chart"></canvas></div>
        </div>
    </div>

    <script>
        // Global variables
        let processedData = {}; 
        let currentCharts = {}; // To store chart instances for destruction/update
        const fractions = [1, 5, 10]; 

        const categories = {
            t_overall: { title: 'Overall Run Time', unit: 'Seconds (s)', order: 1 },
            t_total_pipeline: { title: 'Core Pipeline Time (Features + Training)', unit: 'Seconds (s)', order: 2 },
            t_load: { title: 'Data Loading Time', unit: 'Seconds (s)', order: 3 },
            t_features: { title: 'Feature Engineering Time', unit: 'Seconds (s)', order: 4 },
            f1_score: { title: 'Training F1-Score', unit: 'F1 Score', order: 5, min: 0.7, max: 0.8 }
        };

        const configColors = {
            '32E/12G/2C': { color: 'rgba(239, 68, 68, 0.8)', label: '32 Execs (12G/2C)' }, // Red
            '24E/16G/2C': { color: 'rgba(59, 130, 246, 0.8)', label: '24 Execs (16G/2C)' }, // Blue
            '16E/16G/2C': { color: 'rgba(16, 185, 129, 0.8)', label: '16 Execs (16G/2C)' }, // Green
            '8E/16G/2C': { color: 'rgba(245, 158, 11, 0.8)', label: '8 Execs (16G/2C)' } // Amber
        };


        /**
         * Reads the selected files asynchronously and triggers processing.
         * @param {FileList} files - The list of files selected by the user.
         */
        async function handleFileSelect(files) {
            const statusElement = document.getElementById('fileStatus');
            const overlay = document.getElementById('initial-overlay');
            
            if (files.length === 0) {
                statusElement.textContent = "No files selected. Please select all metrics files.";
                return;
            }

            statusElement.textContent = `Reading ${files.length} files...`;
            overlay.innerHTML = '<p class="text-2xl font-medium text-indigo-600">Processing files...</p>';
            overlay.classList.remove('hidden');

            const fileReaders = [];
            
            // Read each file as text
            for (const file of files) {
                fileReaders.push(new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const content = JSON.parse(event.target.result);
                            resolve({ filename: file.name, content: content });
                        } catch (e) {
                            console.error(`Error parsing JSON in file ${file.name}:`, e);
                            reject(`Invalid JSON in file: ${file.name}`);
                        }
                    };
                    reader.onerror = reject;
                    reader.readAsText(file);
                }));
            }

            try {
                // Wait for all files to be read and parsed
                const results = await Promise.all(fileReaders);
                
                // Process and render
                processedData = processRawData(results);
                renderAllCharts();

                statusElement.textContent = `${results.length} files successfully loaded and plotted!`;
                overlay.classList.add('hidden'); // Hide overlay after success

            } catch (error) {
                statusElement.textContent = `Error: ${error}`;
                overlay.innerHTML = `<p class="text-xl font-medium text-red-600">Error loading data: ${error}</p>`;
            }
        }


        /**
         * Processes the array of JSON data objects and restructures them
         * for charting by grouping metrics by configuration and ordering by fraction.
         */
        function processRawData(files) {
            const configGroups = {};
            const finalData = {};

            // 1. Group data by Configuration Key
            files.forEach(file => {
                const data = file.content;
                
                // Ensure essential fields exist before proceeding
                if (data.num_executors === undefined || data.executor_memory_gb === undefined || data.executor_cores === undefined || data.sample_fraction === undefined) {
                    console.warn(`Skipping file ${file.filename}: Missing required configuration fields.`);
                    return;
                }

                // Configuration Key Format: X executors / Y GB memory / Z cores
                const configKey = `${data.num_executors}E/${data.executor_memory_gb}G/${data.executor_cores}C`;
                
                if (!configGroups[configKey]) {
                    configGroups[configKey] = {};
                }
                
                // Key by fraction (1, 5, 10) for sorting convenience
                // Convert 0.01 -> 1, 0.05 -> 5, 0.1 -> 10
                const fractionKey = Math.round(data.sample_fraction * 100); 
                
                configGroups[configKey][fractionKey] = {
                    t_load: data.t_load,
                    t_features: data.t_features,
                    t_total_pipeline: data.t_total_pipeline,
                    t_overall: data.t_overall,
                    f1_score: data.f1_score
                };
            });

            // 2. Final restructure and sort by Fraction
            const sortedFractions = [1, 5, 10]; 

            for (const configKey in configGroups) {
                const configData = configGroups[configKey];
                finalData[configKey] = {
                    t_load: [], t_features: [], t_total_pipeline: [], t_overall: [], f1_score: []
                };
                
                sortedFractions.forEach(f => {
                    const entry = configData[f];
                    if (entry) {
                        finalData[configKey].t_load.push(entry.t_load);
                        finalData[configKey].t_features.push(entry.t_features);
                        finalData[configKey].t_total_pipeline.push(entry.t_total_pipeline);
                        finalData[configKey].t_overall.push(entry.t_overall);
                        finalData[configKey].f1_score.push(entry.f1_score);
                    }
                });
            }

            return finalData;
        }

        /**
         * Generates a Chart.js dataset structure for a single category.
         * @param {string} categoryKey - e.g., 't_overall'
         * @returns {Array} Array of Chart.js dataset objects.
         */
        function generateDatasets(categoryKey) {
            // Use the globally processed data
            const datasets = Object.keys(processedData).map(configKey => {
                const configData = processedData[configKey][categoryKey];
                const colorConfig = configColors[configKey] || { color: 'rgba(108, 117, 125, 0.8)', label: configKey }; // Fallback color
                
                // Only include configurations that have data points
                if (configData.length === 0) return null;

                return {
                    label: colorConfig.label,
                    data: configData.map((y, i) => ({ x: fractions[i], y: y })),
                    borderColor: colorConfig.color,
                    backgroundColor: colorConfig.color.replace('0.8', '0.2'),
                    borderWidth: 3,
                    pointRadius: 6,
                    tension: 0.4, 
                };
            }).filter(d => d !== null); // Remove null datasets

            // If no data is generated, show an error
            if (datasets.length === 0) {
                console.error("No valid data found to plot.");
                return [];
            }
            return datasets;
        }

        /**
         * Creates and renders a Chart.js line chart.
         * @param {string} canvasId - The ID of the canvas element.
         * @param {string} categoryKey - The key from the categories object.
         */
        function renderChart(canvasId, categoryKey) {
            const ctx = document.getElementById(canvasId).getContext('2d');
            const category = categories[categoryKey];
            const datasets = generateDatasets(categoryKey);

            // Destroy existing chart instance if it exists
            if (currentCharts[canvasId]) {
                currentCharts[canvasId].destroy();
            }

            if (datasets.length === 0) {
                 // Clear canvas if no data to display (e.g., if a category is missing)
                 ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                 return;
            }

            const config = {
                type: 'line',
                data: {
                    labels: fractions.map(f => f + '%'),
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                padding: 15,
                                usePointStyle: true,
                                font: { size: 11 }
                            }
                        },
                        title: {
                            display: true,
                            text: category.title,
                            font: { size: 14, weight: 'bold' },
                            padding: { top: 10, bottom: 10 }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Data Fraction (%)' },
                            grid: { display: false }
                        },
                        y: {
                            title: { display: true, text: category.unit },
                            min: category.min !== undefined ? category.min : undefined,
                            max: category.max !== undefined ? category.max : undefined,
                        }
                    }
                }
            };

            currentCharts[canvasId] = new Chart(ctx, config);
        }

        /** Renders all charts. */
        function renderAllCharts() {
            renderChart('t_overall_chart', 't_overall');
            renderChart('t_total_pipeline_chart', 't_total_pipeline');
            renderChart('t_load_chart', 't_load');
            renderChart('t_features_chart', 't_features');
            renderChart('f1_score_chart', 'f1_score');
        }

    </script>
</body>
</html>